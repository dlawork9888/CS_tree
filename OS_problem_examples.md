# 운영체제 연습 문제
1. 컴퓨터 시스템을 계층적으로 묘사할 때 운영체제의 위치는 다음 그림의 어느 부분에 해당하는가?
    - 사용자
    - 응용프로그램
    - 유틸리티
    - "OS"
    - 하드웨어
2. 운영체제에 대한 설명으로 옳지 않은 것은?
    1. 다중 사용자와 다중 응용 프로그램 환경 하에서 자원의 현재 상태를 파악하고, 자원 분배를 위한 스케줄링을 담당 
        - O
    2. CPU, 메모리 공간, 기억장치, 입출력장치 등의 자원을 관리
        - O
    3. 운영체제의 종류로는 매크로 프로세서, 어셈블러, 컴파일러 등이 있다.
        - X, 프로세스 컴파일 과정의 구성 요소, 시스템 소프트웨어의 한 종류들임
    4. 입출력장치와 사용자 프로그램을 제어
        - O
3. 운영체제를 기능에 따라 분류할 경우, 제어 프로그램이 아닌 것은?
    1. 데이터 관리 프로그램
    2. 서비스 프로그램
        - X
    3. 작업 제어 프로그램
    4. 감시 프로그램
4. 운영체제의 기능으로 틀린 것은? 
    1. 자원 스케줄링 기능을 제공
    2. 자원 보호 기능
    3. 사용자와 시스템 간의 편리한 인터페이스 제공
    4. 목적 프로그램과 라이브러리, 실행 프로그램 등을 연결하여 실행가능한 로드 모듈을 만듦
        - 라이브러리를 동적, 정적 링킹 -> 링커의 기능
5. 운영체제의 목적으로 거리가 먼 것은?
    1. 처리 능력의 향상
    2. 반환 시간의 최대화
        - 최소화 해야함
    3. 사용 가능도 증대
    4. 신회도 향상
6. 운영체제의 성능 판단 요소로 거리가 먼 것은?
    1. 처리 능력
    2. 비용
    3. 신회도
    4. 사용 가능도
        - 운영체제의 성능 판단 기준 : 처반사신
7. 운영체제의 성능평가 요인 중 다음 설명에 해당하는 것은?
    - 이것은 컴퓨터 시스템 내의 한정된 각종 자원을 여러 사용자가 요구할 때, 어느 정도 신속하고 충분히 지원해 줄 수 있는지의 정도.
    - 이는 사용 가능한 하드웨어 자원의 수나 다중 프로그래밍 정도 등의 요소가 좌우하는 것으로, 같은 종류의 시스템 자원수가 많을 경우 이것이 높아질 수 있음
    1. Throughput => 사용 가능도
    2. Availablity
    3. Turn Around Time
    4. Reliablitiy
8. 가상기억장치에 대한 설명 중 옳지 않은 것은?
    1. 동적주소변환(DAT) 기법은 프로세스가 수행될 때 가상 주소를 실주소로 바꾸어 준다.
    2. 크기가 고정된 블록을 페이지라 하며, 크기가 변할 수 있는 블록을 세그먼트라 한다.
    3. 인위적 연속성(Artificial Contiguity)이란 가상주소 공간상의 연속적인 주소가 주기억장치에서도 인위적으로 연속성을 보장해야하는 성질을 말한다.
        - 인위적 연속성: 가상주소공간 상의 연속적인 주소가 실저장장치에서 연속적일 필요가 없음
    4. 세그먼트 기법에서 한 프로세스의 세그먼트들은 동시에 모두 기억장치 내에 있을 필요가 없으며, 연속적일 필요도 없다.
        - O
9. 요구 페이징 기법 중 가장 오랫동안 사용되지 않았던 페이지를 먼저 교체하는 기법에 해당되는 것은?
    1. FIFO
    2. LFU
        - "Least Frequently" Used
        - 사용 빈도가 적은 것
    3. LRU
        - "Least Recently" Used
        - "최근에 가장 적게 사용된 것"
        - 가장 오랫동안 안쓴 녀석을 교체
    4. NUR
        - "Not Used" Recently 
        - "최근에 사용되지 않은 것"
10. 4개의 페이지를 수용할 수 있는 주 기억장치가 있으며, 초기에는 모두 비어있다고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, FIFO 페이지 교체 알고리즘을 사용할 경우 페이지 결함의 발생횟수는?
    - 페이지 참조순서: 1 2 3 1 2 4 5 1 
11. 4개의 페이지를 수용할 수 있는 주 기억장치가 있으며, 초기에는 모두 비어있다고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, LRU 페이지 교체 알고리즘을 사용할 경우 페이지 결함의 발생횟수는?
    - 페이지 참조 순서: 1 2 3 1 2 4 1 2 5
12. 페이지 교체 기법 중 매 페이지마다 두 개의 하드웨어 비트, 즉 참조 비트와 변형 비트가 필요한 기법은?
    1. FIFO
    2. LRU
    3. LFU
    4. NUR => 참조 비트, 변형 비트 필요
        - 참조비트
            - 페이지가 호출 X -> 0
            - 페이지가 호출 O -> 1
        - 변형비트
            - 페이지 내용이 변경 X -> 0
            - 페이지 내용이 변경 O -> 1
        - 참조비트/변형비트/교체순서
            - 0 0 -> 1
            - 0 1 -> 2
            - 1 0 -> 3
            - 1 1 -> 4
13. NUR 기법은 호출비트와 변형비트를 가진다. 다음 중 가장 나중에 교체될 페이지는?
    - 호출비트/변형비트
    1. 0 0
    2. 0 1
    3. 1 0
    4. 1 1

14. 다음 중 페이지 교체 알고리즘이 아닌 것은?
    1. FIFO
    2. LUF -> 이런 거 없음
    3. Optimal
    4. LRU
15. 페이징 기법과 세그멘테이션 기법에 대한 설명으로 옳지 않은 것은?
    1. 페이징 기법에서는 주소변환을 위한 페이지 맵 테이블이 필요하다
    2. 프로그램을 일정한 크기로 나눈 단위를 페이지라고 한다.
    3. 세그멘테이션 기법에서는 하나의 작업을 크기가 각각 다른 여러 논리적인 단위로 나누어 사용한다.
    4. 세그멘테이션 기법에서는 내부단편화가, 페이징 기법에서는 외부 단편화가 발생한다.
        - 세그멘테이션 => 들어갈 자리 모으면 충분한데 조각조각 나있어서 못들어감 => 외부 단편화
        - 페이징 기법 => 페이지에 적재시키니 메모리 공간이 많이 남음, 그 남는데 다른 녀석은 못들어감 -> 내부 단편화
16. 다음 설명의 ㄱ과 ㄴ에 들어갈 내용으로 옳은 것은?
    - 가상기억장치의 일반적인 구현 방법에는 프로그램을 고정된 크기의 일정한 블록으로 나누는 ㄱ 기법과 가변적인 크기의 블록으로 나누는 ㄴ 기법이 있다.
    ㄱ. Paging
    ㄴ. Segmentaion
17. 세그멘테이션 기법에 대한 설명으로 옳지 않은 것은?
    1. 각 세그먼트는 고유한 이름과 크기를 갖는다.
        - 그런가봄. 의미 단위로 쪼개서 그런가
    2. 세그먼트 맵 테이블이 필요하다. 
    3. 프로그램을 일정한 크기로 나눈 단위를 세그먼트라고 한다.
        - 가변 크기임
    4. 기억장치 보호키가 필요하다.
18. 다음과 같은 세그먼트 테이블을 가지는 시스템에서 논리 주소(2, 176)에 대한 물리 주소는?
    - 세그먼트번호/시작주소/길이(바이트)
        - 0 670 248
        - 1 1752 422
        - 2 222 198
        - 3 996 604
    - 논리 주소 (2,176) => 세그먼트2 + 176 => 222 + 176 = 398
19. 페이징 기법에 대한 설명으로 옳지 않은 것은?
    1. 동적 주소 변환 기법을 사용하여 다중 프로그래밍의 효과를 증진시킨다.
        - 실행시간에 주소변환을 실행 -> 페이지가 있으면 히트, 없으면 폴트
    2. 내부 단편화가 발생하지 않는다.
        - 파티션의 크기가 프로세스의 크기보다 커서 메모리가 남지만 다른 프로세스가 쓸 수 없음 -> 내부 단편화 발생
    3. 프로그램을 동일한 크기로 나눈 단위를 페이지라고 하며, 이 페이지를 블록으로 사용하는 기법이다. 
    4. 페이지 맵 테이블이 필요하다   
20. 가상기억장치에서 주기억장치로 페이지를 옮겨넣을 때, 주소를 조정해주어야 하는데, 이를 무엇이라 하는가?
    1. 매핑 O -> 사상
    2. 스케줄링
    3. 매핑
    4. 로딩
21. 기억장치 관리 전략은 주기억장치의 자원을 가장 잘 사용하도록 설계되어야 하는데, 다음 중 주기억장치 관리 전략과 거리가 먼 것은?
    1. Fetch 
    2. Placement
    3. Paging
    4. Replacement
    - 주기억장치 관리 전략에는 반입, 배치, 교체 전략이 있음.
    - 페이징 기법은 가상기억장치에서 사용되는 기법
22. 기억장치의 관리 전략 중 반입 전략의 설명으로 맞는 것은?
    1. 프로그램/데이터를 주기억장치로 가져오는 시기를 결정하는 전략
        - 반입
    2. 프로그램/데이터의 주기억장치 내의 위치를 정하는 전략
        - 배치
    3. 주기억장치 내의 빈 공간 확보를 위해 제거할 프로그램/데이터를 선택하는 전략
        - 교체
    4. 프로그램/데이터의 위치를 이동시키는 전략
        - X
23. 빈 기억 공간이 15K, 23K, 22K, 21K 순으로 빈 공간이 있을 때, 기억장치 배치 전략으로 First Fit을 사용하여 17K의 프로그램을 적재할 경우, 내부 단편화의 크기는 얼마인가?
    - 6K
24. 빈 기억 공간이 20KB, 16KB, 8KB, 40KB 순으로 빈 공간이 있을 때, 기억장치 배치 전략으로 Best Fit을 사용하여 17KB의 프로그램을 적재할 경우, 내부 단편화의 크기는 얼마인가?
    - 3KB
25. 메모리 관리 기법 중 Worst Fit 방법을 사용할 경우 10K 크기의 프로그램을 실행을 위해서는 어느 부분에 할당되는가?
    - 영역번호/메모리크기/사용여부
        - NO1/8K/FREE
        - NO2/12K/FREE
        - NO3/10K/IN USE
        - NO4/20K/IN USE
        - NO5/16K/FREE
    - NO4는 쓰고 있으므로 할당 못함. NO5 -> 6K
26. 가상기억장치의 페이지 교체 알고리즘이 아닌 것은?
    1. FIFO
    2. LRU
    3. SSTF -> 이건 디스크 스케줄링
    4. LFU
27. 페이징 기법에서 페이지 크기가 작아질수록 발생하는 현상이 아닌 것은?
    1. 기억장소 이용 효율 증가
    2. 입출력 시간이 늘어난다
    3. 내부 단편화가 감소한다
    4. 페이지 맵 테이블의 크기가 
        - 페이지 수가 많아지므로 페이지 맵 테이블이 커짐
28. 프로세스 적재 정책과 관련된 설명으로 틀린 것은?
    1. 반복, 스택, 부프로그램은 시간 지역성과 관련이 있다.
        - 어떤 페이지가 참조되면, 가까운 시간 내에 다시 그 페이지를 참조할 가능성이 높다.
        - 반복문을 생각해보면 편함.
    2. 공간 지역성은 프로세스가 어떤 페이지를 참조했다면 이후 가상주소공간상 그 페이지와 인접한 페이지들은 참조할 가능성이 높음을 의미한다.
    3. 일반적으로 페이지 교환에 보내는 시간보다 프로세스 수행에 보내는 시간이 더 크면 스레싱이 발생한다.
        - 페이지 교환에 더 많은 시간을 쏟아 CPU 이용률이 저조한 것이 스레싱
    4. 스레싱 현상을 방지하기 위해서는 각 프로세스가 필요로 하는 프레임을 제공할 수 있어야한다.
29. 시간 구역성과 거리가 먼 것은?
    1. 스택
    2. 부프로그램
    3. 순환문
    4. 배열 순회 => 얘는 공간 지역성
30. 프로세스들이 국부적인 부분만을 집중적으로 참조하는 구역성에는 시간 구역성과 공간 구역성이 있는데, 다음 중 공간 구역성의 경우는?
    1. 스택
    2. 집계에 사용되는 변수 => 얘도 결국 반복문으로 생각하면 편함
    3. 순환문
    4. 배열 순회
31. 운영체제의 가상기억장치 관리에서 프로세스가 일정 시간동안 자주 참조하는 페이지들의 집합을 의미하는 것은?
    1. Locality
    2. Deadlock
    3. Thrashing
    4. Working Set -> O
32. 페이지 오류율과 스레싱에 대한 설명으로 옳은 것은?
    1. 페이지 오류율이 크면 스레싱이 많이 발생한 것이다.
        - 페이지 폴트 많이 발생 -> 교체 많이 발생 -> CPU 이용율 감소 
    2. 페이지 오류율과 스레싱은 전혀 관계가 없다.
    3. 스레싱이 많이 발생하면 페이지 오류율이 감소한다.
    4. 다중 프로그래밍 정도가 높을수록 페이지 오류율과 스레싱이 감소한다.
33. Working set W(t,w)s는 t-w시간부터 t까지 참조된 페이지들의 집합을 말한다. 그 시간에 참조된 페이지가 {2,3,5,5,6,3,7}이라면, Working Set은? 
    - {2,3,5,6,7}
    - 일정 시간 동안 참조하는 페이지들의 집합 -> 중복 제거
34. 다음 설명에 해당하는 내용은 무엇인가?
    - 프로세스 처리 도중, 참조할 페이지가 주기억장치에 없어 프로세스 처리시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상
    - 스레싱
35. 다음과 같은 프로세스가 차례로 큐에 도착하였을 때, SJF정책을 사용할 경우 가장 먼저 처링되는 작업은?
    - 프로세스번호/실행시간
        - P1/6
        - P2/8
        - P3/4
        - P4/3
    - P4
36. HRN 스케줄링에서 우선순위 계산식은?
    - (대기시간 + 서비스시간)/서비스시간
37. 선점 기법의 스케줄링에 해당하는 것은?
    1. FIFO
    2. SJF
    3. HRN
    4. RR -> 일종의 시분할 기법, 타임 슬라이스를 프로세스에 할당
38. 선점 기법과 대비하여 비선점 스케줄링 기법에 대한 설명으로 옳지 않은 것은?
    1. 모든 프로세스들에 대한 요구를 공정히 처리한다. -> 공정히 -> 안빼앗음 -> 비선점
    2. 응답시간의 예측이 용이하다. -> 비선점
    3. 많은 오버헤드를 초래할 수 있다. -> 선점 <- 빼앗음
    4. CPU의 사용시간이 짧은 프로세스들이 사용 시간이 긴 프로세스들로 인하여 오래 기다리는 경우가 발생할 수 있다. -> 비선점
39. 선점 스케줄링 방식에 대한 설명으로 옳지 않은 것은?
    1. 대화식 시분할 시스템에 적합하다.
        - 그런가봄
    2. 긴급하고 높은 우선순위의 프로세스들이 빠르게 처리될 수 있다.
    3. 일단 CPU를 할당받으면 다른 프로세스가 CPU를 강제적으로 빼앗을 수 없는 방식이다.
        - 빼앗을 수 있음
    4. 선점을 위한 시간 배당에 대한 인터럽트용 타이머 클록이 필요하다.
40. 비선점 스케줄링 방식에 해당하는 것으로만 짝지어진 것은?
    1. FCFS, SJF -> 다 비선점
    2. RR, SRT
    3. SRT, SJF
    4. MQ, FCFS
41. 다음 중 프로세스에 대한 설명 중 틀린 것은?
    1. 프로세서가 할당되는 실체로, 디스패치가 가능한 단위이다.
    2. 프로세스는 비동기적 행위를 일으키는 주체이다.
        - 그런가봄
        - 동기화 문제는 스레드든 프로세스는 발생함
    3. 프로세스는 스레드 내의 작업 단위를 의미하며, 경량 스레드라고도 불린다.
        - 스레드는 프로세스의 작업 단위, 프로세스 내의 작업 흐름을 의미 
    4. PCB를 가지며, PCB에는 프로세스의 현재 상태, 고유 식별자를 가지고 있다.
42. 사용자 수준에서 지원되는 스레드가 커널에서 지원되는 스레드에 비해 가지는 장점으로 옳은 것은?
    1. 한 프로세스가 운영체제를 호출할 때, 전체 프로세스가 대기할 필요가 없으므로 시스템 성능을 높일 수 있다.
    2. 동시에 여러 스레드가 커널에 접근할 수 있으므로, 여러 스레드가 시스템 호출을 동시에 사용할 수 있다.
    3. 각 스레드를 개별적으로 관리할 수 있으므로, 스레드의 독립적인 스케줄링이 가능하다.
    4. 커널 모드로의 전환 없이 스레드 교환이 가능하므로, 오버헤드가 줄어든다.
    - 1,2,3은 커널 수준의 스레드의 장점
43. 프로세스 제어 블록(PCB)에 대한 설명으로 옳은 것은?
    1. 프로세스에 할당된 자원에 대한 정보를 가지고 있다.
    2. 프로세스의 우선순위에 대한 정보를 가지고 있다.
    3. 부모 프로세스와 자식 프로세스는 PCB를 공유한다.
        - 부모 자식 프로세스는 엄연히 다른 프로세스이므로 PCB는 따로 가진다.
    4. 프로세스의 현 상태를 알 수 있다.
44. PCB가 갖고 있는 정보가 아닌 것은?
    1. 프로세스 상태
    2. 프로그램 카운터
    3. 처리기 레지스터
    4. 할당되지 않은 주변 장치의 상태 정보
        - 해당 프로세스에 관련된 정보만을 가짐
45. 프로세스 상태의 종류가 아닌 것은?
    1. Ready
    2. Running
    3. Request
    4. Exit
    - 프로세스 상태는 Submit(제출), Hold(접수), [Ready, Wait, Running], Exit(종료)로 구분된다.
46. 준비 상태에서 대기하고 있는 프로세스 중 하나가 스케줄링되어 중앙처리장치를 할당받아 실행상태로 전이되는 과정을 무엇이라 하는가?
    1. 실행
    2. 대기
    3. 준비
    4. 디스패치 O
47. 스레드에 대한 설명으로 옳지 않은 것은?
    1. 한 개의 프로세스는 여러 개의 스레드를 가질 수 없다.
        - 여러 스레드 가질 수 있음
    2. 커널 스레드의 경우 운영체제에 의해 스레드를 운용한다. 
    3. 사용자 스레드의 경우 사용자가 만든 라이브러리를 사용하여 스레드를 운용한다.
    4. 스레드를 사용함으로써 하드웨어, 운영체제의 성능과 응용 츠로그램의 처리율을 향상 시킬 수 있다. 
48. 프로세스와 관련된 설명으로 틀린 것은?
    1. 프로세스가 준비 상태에서 프로세서가 배당되어 실행 상태로 변화하는 것을 디스패치라고 한다.
    2. 프로세스 제어 블록은 프로세스 식별자 프로세스 상태 등의 정보로 구성된다.
    3. 이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 적재하는 과정을 문맥교환이라고 한다. 
    4. 프로세스는 스레드 내에서 실행되는 흐름의 단위이며, 달리 주소 공간에 스택이 없다. 
        - 스택있음
        - 프로세스 내 스레드들은 코드, 데이터, 힙 영역을 공유하지만, 별도의 스택 공간을 가짐
49. 워킹 셋에 대한 설명으로 옳지 않은 것은?
    1. 프로세스가 실행하는 과정에서 시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변화하기 떄문에 워킹셋은 시간에 따라 바뀌게 된다.
    2. 프로그램의 구역성 특징을 이용한다.
    3. 워킹 셋에 속한 페이지들을 참조하면, 프로세스의 기억치 사용은 안정상태가 된다.
    4. 페이지 이동에 소요되는 시간과 프로세스 수행에 소요되는 시간의 차이를 의미한다.
        - 아님. 
50. 페이징 기법과 관련된 설명으로 옳지 않은 것은?
    1. 어떤 프로세스가 프로그램 실행에 사용하는 시간보다 페이지 적재/대체에 소비하는 시간이 더 큰 경우에 스레싱이 발생한다.
    2. 페이지 크기가 작을 경우 페이지 테이블의 공간이 많이 요구된다.
    3. 워킹셋 방식은 스래싱을 방지하는 방법 중의 하나이다.
    4. 다중 프로그래밍의 정도가 높을수록 스래싱의 발생빈도는 낮아진다.
        - 다중 프로그래밍 정도가 높아짐 -> 페이지 폴트가 빈번 -> CPU이용율 감소 -> 스레싱 증가
51. 시스템을 설계할 때 최적의 페이지 크기에 관한 결정이 이루어져야만 한다. 페이지 크기에 관한 설명으로 옳지 않은 것은?
    1. 페이지 크기가 크면 페이지 테이블 공간은 증가한다.
        - 페이지 크기가 큼 -> 페이지 수는 작음 -> 페이지 테이블 작음
    2. 입출력 전송시 큰 페이지가 더 효율적이다
        - 맞나봄
        - 입출력이 빈번히 안 일어나서 그런가봄
    3. 페이지 크기가 클수록 디스크 접근 시간 부담이 감소된다.
        - 2번이랑 일맥 상통
    4. 페이지 크기가 작아도 페이지 테이블의 단편화는 발생한다.
        - ? 페이지 테이블 단편화가 뭐냐
52. 실행중인 프로세스는 일정 시간에 메모리의 일정 부분만을 집중적으로 참조한다는 개념을 의미하는 것은?  
    - (시간) 지역성
53. 페이지 대체 문제에 관련된 사항 중 잘못된 것은?
    1. 스래싱 현상이 일어나면 시스템의 처리율이 증가한다.
        - CPU 이용률이 감소함 -> 시스템의 처리 효율이 박살난다는 소라
    2. 시간 지역성이란 최근에 참조한 기억장소가 다시 참조될 가능성인 높다는 것이다.
    3. 공간 지역성이란 참조된 기억장소에 대해 근처의 기억장소가 다시 참조될 가능성이 높다는 것이다.
    4. 어떤 프로세스가 빈번하게 참조하는 페이지들의 집합을 작업셋이라고 한다.
54. 스레싱 현상의 해결 조치로 틀린 것은?
    1. 부족한 자원을 증설한다
    2. 일부 프로세스를 중단시킨다
    3. 성능 자료의 지속적 관리 및 분석으로 임계치를 예상하여 운영한다.
        - 다중 프로그래밍 정도를 일정 수준까지만 유지한다는 소리
    4. 다중 프로그래밍 정도를 높인다.
        - 일정 수준 넘어가면 CPU 이용률 감소함.
